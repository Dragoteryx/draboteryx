"use strict";

// IMPORTS
const ytdl = require("ytdl-core");
const youtubeSearch = require("youtube-search");
const EventEmitter = require("events");

//FUNCTIONS
exports.videoWebsite = str => {
	if (str.startsWith("https://www.youtube.com/watch?v=") || str.startsWith("https://youtu.be/"))
		return "Youtube";
	/*else if (str.startsWith("http://www.dailymotion.com/video/") || str.startsWith("http://dai.ly/"))
		return "Dailymotion";
	else if (str.startsWith("http://www.nicovideo.jp/watch/") || str.startsWith("http://nico.ms/"))
		return "NicoNicoVideo";*/
	else throw new Error("unknownOrNotSupportedVideoWebsite");
}

exports.playYoutube = (voiceConnection, link, passes) => {
	return voiceConnection.playStream(ytdl(link, {filter:"audioonly"}), {passes: passes, bitrate:"auto"});
}

exports.youtubeInfo = link => {
	return new Promise((resolve, reject) => {
		ytdl.getInfo(link).then(info => {
			resolve(Object.freeze({
				title: info.title,
				description: info.description,
				author: {
					name: info.author.name,
					avatarURL: info.author.avatar,
					channelURL: info.author.channel_url
				},
				thumbnailURL: info.thumbnail_url,
				length: Number(info.length_seconds)*1000,
				link: link
			}));
		}, err => {
			reject(err);
		});
	});
}

exports.queryYoutube = (query, ytbApiKey) => {
	return new Promise((resolve, reject) => {
		youtubeSearch(query, {key: ytbApiKey, maxResults: 1, type: "video"}, (err, res) => {
			if (err) reject(err);
			else resolve(res[0].link);
		});
	});
}

//CLASSES
exports.MusicHandler = function(client) {
	EventEmitter.call(this);
	if (client === undefined)
		throw new Error("MissingParameter: client");
	var playlists = new Map();
	this.getClient = () => client;
	this.joined = () => {
		let guilds = new Map();
		let ids = Array.from(playlists.keys());
		for (let id of ids)
			guilds.set(id, playlists.get(id).guild);
		return guilds;
	}
	this.nbJoined = () => playlists.size;
	this.join = member => {
		if (this.isConnected(member.guild))
			return Promise.reject(new Error("clientAlreadyInAVoiceChannel"));
		if (member.voiceChannel === undefined)
			return Promise.reject(new Error("memberNotInAVoiceChannel"));
		if (!member.voiceChannel.joinable)
			return Promise.reject(new Error("voiceChannelNotJoinable"));
		if (!member.voiceChannel.speakable)
			return Promise.reject(new Error("voiceChannelNotSpeakable"));
		if (member.voiceChannel.full)
			return Promise.reject(new Error("voiceChannelFull"));
		playlists.set(member.guild.id, {playlist: new Playlist(member.guild, client), guild: member.guild});
		playlists.get(member.guild.id).playlist.on("next", (guild, music) => {
			this.emit("next", guild, music);
		});
		playlists.get(member.guild.id).playlist.on("empty", guild => {
			this.emit("empty", guild);
		});
		playlists.get(member.guild.id).playlist.on("finished", (guild, music) => {
			this.emit("finished", guild, music);
		});
		member.voiceChannel.join();
		return Promise.resolve();
	}
	this.leave = guild => {
		return new Promise((resolve, reject) => {
			if (!this.isConnected(guild))
				reject(new Error("clientNotInAVoiceChannel"));
			playlists.get(guild.id).playlist.kill();
			guild.me.voiceChannel.leave();
			playlists.delete(guild.id);
			resolve();
		});
	}
	this.addMusic = (request, member, options) => {
		return new Promise((resolve, reject) => {try {
			if (request === undefined) reject(new Error("MissingParameter: request"));
			if (member === undefined) reject(new Error("MissingParameter: member"));
      if (!this.isConnected(member.guild))
				reject(new Error("clientNotInAVoiceChannel"));
      if (options === undefined) options = {};
      if (options.type === undefined) options.type = "link";
      if (options.passes === undefined) options.passes = 1;
      if (options.type == "link") {
        exports.youtubeInfo(request).then(info => {
					let music = new Music(link, member, options.passes);
	        music.title = info.title;
					music.description = info.description;
					music.author = {
						name: info.author.name
						avatarURL: info.author.avatarURL,
						channelURL: info.author.channelURL
					}
					music.thumbnailURL = info.thumbnailURL;
					music.length = info.length;
					music.time = 0;
	        if (options.props !== undefined)
						music.props = options.props;
					playlists.get(member.guild.id).playlist.addMusic(music);
					resolve(music.info());
				}).catch(console.error);
      } else if (options.type == "ytquery") {
				exports.queryYoutube(request).then(link => {
					options.type = "link";
					resolve(this.addMusic(link, member, options));
				}).catch(reject)
      } else if (options.type == "file") {
				reject(new Error("FeatureNotImplementedYet"));
      } else reject(new Error("InvalidParameter: options.type => '" + options.type + "' is not a valid option ('link', 'ytquery' or 'file')"));
    } catch(err) {
      reject(err)
    }});
	}
}

exports.MusicHandler.prototype = Object.create(EventEmitter.prototype);
exports.MusicHandler.prototype.constructor = exports.MusicHandler;

function Playlist(guild, client) {
	var list = [];
	this.addMusic = () => {

	}
}

/*function Playlist(guild, client) {
	EventEmitter.call(this);
	var list = [];
	var dispatcher = null;
	var current;
	var toNext = false;
	var volume = 100;
	this.loop = false;
	this.plLoop = false;

	// METHODES
	this.loop = () => {
		if (toNext)
			this.playNext();
	}
	this.toggleLooping = () => {
		if (this.plLoop)
			this.plLoop = false;
		this.loop = !this.this.loop;
		return this.loop;
	}
	this.togglePlaylistLooping = () => {
		if (this.loop)
			this.loop = false;
		this.plLoop = !this.plLoop;
		return this.plLoop;
	}
	this.add = music => {
		list.push(music);
		if (!this.isPlaying())
			toNext = true;
	}
	this.remove = index => {
		return list.splice(index, 1)[0];
	}
	this.skip = () => {
		loop = false;
		dispatcher.end();
	}
	this.playNext = () => {
		toNext = false;
		dispatcher = null;
		if (this.plLoop)
			list.push(current);
		if (!this.loop)
			current = list.shift();
		if (current !== undefined) {
			dispatcher = current.play();
			dispatcher.setVolume(volume/100.0);
			dispatcher.once("end", () => {
				toNext = true;
				this.emit("finished", guild, current.info());
			});
			this.emit("next", guild, current.info());
		} else {
			this.reset();
			this.emit("empty", guild);
		}
	}
	this.toggle = () => {
		if (this.isPaused())
			return this.resume();
		else
			return this.pause();
	}
	this.pause = () => {
		if (this.isPaused())
			throw new Error("musicNotPaused");
		dispatcher.pause();
		return true;
	}
	this.resume = () => {
		if (!this.isPaused())
			throw new Error("musicAlreadyPaused");
		dispatcher.resume();
		return false;
	}
	this.shuffle = () => {
		list.sort(() => Math.random() - 0.5);
	}
	this.clear = () => {
		list = [];
	}
	this.setVolume = set => {
		let oldVolume = volume;
		volume = set;
		if (dispatcher != null)
			dispatcher.setVolume(volume/100.0);
		return oldVolume;
	}
	this.reset = () => {
		list = [];
		if (dispatcher != null)
			dispatcher.end();
		dispatcher = null;
		current = undefined;
	}
	this.kill = () => {
		this.reset();
		client.clearInterval(interval);
	}

	// INFOS
	this.info = () => {
		let list2 = [];
		for (let music of list)
			list2.push(music.info());
		return list2;
	}
	this.playingInfo = () => {
		let info = current.info();
		info.time = dispatcher.time;
		return info;
	}
	this.isPlaying = () => current !== undefined && dispatcher != null;
	this.isPaused = () => dispatcher.paused;
	this.size = () => list.length;
	this.isEmpty = () => list.length == 0;
	this.musicInfo = index => list[index].info();
	this.remainingTime = () => {
		let remaining = 0;
		if (this.isPlaying)
			remaining += current.length-dispatcher.time;
		for (let music of list)
			remaining += music.length;
		return remaining;
	}
	var interval = client.setInterval(this.loop, 1000);
}

Playlist.prototype = Object.create(EventEmitter.prototype);
Playlist.prototype.constructor = Playlist;

function Music(link, member, file, passes) {
	if (!file)
		this.website = exports.videoWebsite(link);
	else
		this.title = link.split("/").pop();
	this.link = link;
	this.member = member;
	this.file = file;
	this.passes = passes;
	this.play = () => {
		if (!this.file) {
			if (this.website == "Youtube")
				return exports.playYoutube( this.member.guild.me.voiceChannel.connection, this.link, this.passes);
			else if (this.website == "Dailymotion")
				return this.member.guild.me.voiceChannel.connection.playStream(null);
			else if (this.website == "NicoNicoVideo")
				return this.member.guild.me.voiceChannel.connection.playStream(null);
		}
		return this.member.guild.me.voiceChannel.connection.playFile(this.link);
	}
	this.info = () => {
		let object;
		if (!this.file)
			object = {
				title : this.title,
				description : this.description,
				author : this.author,
				thumbnailURL : this.thumbnailURL,
				length : this.length,
				link : this.link,
				member : this.member,
				file : false
			};
		else
			object = {
				name : this.title,
				path : this.link,
				member : this.member,
				file : true
			};
		if (this.props !== undefined)
			object.props = this.props;
		return objectS;
	}
}*/
